

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>odl.operator.tensor_ops &mdash; odl 0.6.1.dev0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="odl 0.6.1.dev0 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> odl
          

          
          </a>

          
            
            
              <div class="version">
                0.6.1.dev0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/getting_started.html">Getting Started</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with ODL</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/guide.html">User&#8217;s guide &#8211; selected topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../math/math.html">Mathematical Background</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer zone</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../dev/dev.html">Contributing to ODL</a></li>
</ul>
<p class="caption"><span class="caption-text">Useful facts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/faq.html">Frequently asked questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release_notes.html">Release Notes</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../refs.html">References</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../odl.html">odl</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">odl</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>odl.operator.tensor_ops</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for odl.operator.tensor_ops</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2014-2017 The ODL contributors</span>
<span class="c1">#</span>
<span class="c1"># This file is part of ODL.</span>
<span class="c1">#</span>
<span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public License,</span>
<span class="c1"># v. 2.0. If a copy of the MPL was not distributed with this file, You can</span>
<span class="c1"># obtain one at https://mozilla.org/MPL/2.0/.</span>

<span class="sd">&quot;&quot;&quot;Operators defined for tensor fields.&quot;&quot;&quot;</span>

<span class="c1"># Imports for common Python 2/3 codebase</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">future</span> <span class="k">import</span> <span class="n">standard_library</span>
<span class="n">standard_library</span><span class="o">.</span><span class="n">install_aliases</span><span class="p">()</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="k">import</span> <span class="nb">super</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span>

<span class="kn">from</span> <span class="nn">odl.operator</span> <span class="k">import</span> <span class="n">Operator</span>
<span class="kn">from</span> <span class="nn">odl.set</span> <span class="k">import</span> <span class="n">RealNumbers</span><span class="p">,</span> <span class="n">ComplexNumbers</span><span class="p">,</span> <span class="n">LinearSpace</span>
<span class="kn">from</span> <span class="nn">odl.space</span> <span class="k">import</span> <span class="n">ProductSpace</span><span class="p">,</span> <span class="n">fn</span>
<span class="kn">from</span> <span class="nn">odl.space.base_ntuples</span> <span class="k">import</span> <span class="n">FnBase</span>
<span class="kn">from</span> <span class="nn">odl.space.npy_ntuples</span> <span class="k">import</span> <span class="n">NumpyFn</span>
<span class="kn">from</span> <span class="nn">odl.util</span> <span class="k">import</span> <span class="n">writable_array</span><span class="p">,</span> <span class="n">signature_string</span><span class="p">,</span> <span class="n">indent_rows</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;PointwiseNorm&#39;</span><span class="p">,</span> <span class="s1">&#39;PointwiseInner&#39;</span><span class="p">,</span> <span class="s1">&#39;PointwiseSum&#39;</span><span class="p">,</span> <span class="s1">&#39;MatrixOperator&#39;</span><span class="p">)</span>

<span class="n">_SUPPORTED_DIFF_METHODS</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;central&#39;</span><span class="p">,</span> <span class="s1">&#39;forward&#39;</span><span class="p">,</span> <span class="s1">&#39;backward&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="PointwiseTensorFieldOperator"><a class="viewcode-back" href="../../../generated/odl.operator.tensor_ops.PointwiseTensorFieldOperator.html#odl.operator.tensor_ops.PointwiseTensorFieldOperator">[docs]</a><span class="k">class</span> <span class="nc">PointwiseTensorFieldOperator</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Abstract operator for point-wise tensor field manipulations.</span>

<span class="sd">    A point-wise operator acts on a space of vector or tensor fields,</span>
<span class="sd">    i.e. a power space ``X^d`` of a discretized function space ``X``.</span>
<span class="sd">    Its range is the power space ``X^k`` with a possibly different</span>
<span class="sd">    number ``k`` of components. For ``k == 1``, the base space</span>
<span class="sd">    ``X`` can be used instead.</span>

<span class="sd">    For example, if ``X`` is a `DiscreteLp` space, then</span>
<span class="sd">    ``ProductSpace(X, d)`` is a valid domain for any positive integer</span>
<span class="sd">    ``d``. It is also possible to have tensor fields over tensor fields, i.e.</span>
<span class="sd">    ``ProductSpace(ProductSpace(X, n), m)``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ProductSpace</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">base_space</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        domain, range : {`ProductSpace`, `LinearSpace`}</span>
<span class="sd">            Spaces of vector fields between which the operator maps.</span>
<span class="sd">            They have to be either power spaces of the same base space</span>
<span class="sd">            ``X`` or the base space itself (only one of them).</span>
<span class="sd">            Empty product spaces are not allowed.</span>
<span class="sd">        base_space : `LinearSpace`</span>
<span class="sd">            The base space ``X``.</span>
<span class="sd">        linear : bool, optional</span>
<span class="sd">            If ``True``, assume that the operator is linear.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">domain</span> <span class="o">!=</span> <span class="n">base_space</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">ProductSpace</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="ow">not</span> <span class="n">domain</span><span class="o">.</span><span class="n">is_power_space</span> <span class="ow">or</span>
                    <span class="n">domain</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`domain` </span><span class="si">{!r}</span><span class="s1"> is neither `base_space` </span><span class="si">{!r}</span><span class="s1"> &#39;</span>
                                <span class="s1">&#39;nor a nonempty power space of it&#39;</span>
                                <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">base_space</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">range</span> <span class="o">!=</span> <span class="n">base_space</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">range</span><span class="p">,</span> <span class="n">ProductSpace</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="ow">not</span> <span class="nb">range</span><span class="o">.</span><span class="n">is_power_space</span> <span class="ow">or</span>
                    <span class="nb">range</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span>
                    <span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">base_space</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`range` </span><span class="si">{!r}</span><span class="s1"> is neither `base_space` </span><span class="si">{!r}</span><span class="s1"> &#39;</span>
                                <span class="s1">&#39;nor a nonempty power space of it&#39;</span>
                                <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">range</span><span class="p">,</span> <span class="n">base_space</span><span class="p">))</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">domain</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="nb">range</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="n">linear</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__base_space</span> <span class="o">=</span> <span class="n">base_space</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">base_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Base space ``X`` of this operator&#39;s domain and range.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__base_space</span></div>


<div class="viewcode-block" id="PointwiseNorm"><a class="viewcode-back" href="../../../generated/odl.operator.tensor_ops.PointwiseNorm.html#odl.operator.tensor_ops.PointwiseNorm">[docs]</a><span class="k">class</span> <span class="nc">PointwiseNorm</span><span class="p">(</span><span class="n">PointwiseTensorFieldOperator</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Take the point-wise norm of a vector field.</span>

<span class="sd">    This operator takes the (weighted) ``p``-norm</span>

<span class="sd">        ``||F(x)|| = [ sum_j( w_j * |F_j(x)|^p ) ]^(1/p)``</span>

<span class="sd">    for ``p`` finite and</span>

<span class="sd">        ``||F(x)|| = max_j( w_j * |F_j(x)| )``</span>

<span class="sd">    for ``p = inf``, where ``F`` is a vector field. This implies that</span>
<span class="sd">    the `Operator.domain` is a power space of a discretized function</span>
<span class="sd">    space. For example, if ``X`` is a `DiscreteLp` space, then</span>
<span class="sd">    ``ProductSpace(X, d)`` is a valid domain for any positive integer</span>
<span class="sd">    ``d``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vfspace</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weighting</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vfspace : `ProductSpace`</span>
<span class="sd">            Space of vector fields on which the operator acts.</span>
<span class="sd">            It has to be a product space of identical spaces, i.e. a</span>
<span class="sd">            power space.</span>
<span class="sd">        exponent : non-zero float, optional</span>
<span class="sd">            Exponent of the norm in each point. Values between</span>
<span class="sd">            0 and 1 are currently not supported due to numerical</span>
<span class="sd">            instability.</span>
<span class="sd">            Default: ``vfspace.exponent``</span>
<span class="sd">        weighting : `array-like` or positive float, optional</span>
<span class="sd">            Weighting array or constant for the norm. If an array is</span>
<span class="sd">            given, its length must be equal to ``domain.size``, and</span>
<span class="sd">            all entries must be positive.</span>
<span class="sd">            By default, the weights are is taken from</span>
<span class="sd">            ``domain.weighting``. Note that this excludes unusual</span>
<span class="sd">            weightings with custom inner product, norm or dist.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        We make a tiny vector field space in 2D and create the</span>
<span class="sd">        standard point-wise norm operator on that space. The operator</span>
<span class="sd">        maps a vector field to a scalar function:</span>

<span class="sd">        &gt;&gt;&gt; spc = odl.uniform_discr([-1, -1], [1, 1], (1, 2))</span>
<span class="sd">        &gt;&gt;&gt; vfspace = odl.ProductSpace(spc, 2)</span>
<span class="sd">        &gt;&gt;&gt; pw_norm = PointwiseNorm(vfspace)</span>
<span class="sd">        &gt;&gt;&gt; pw_norm.range == spc</span>
<span class="sd">        True</span>

<span class="sd">        Now we can calculate the 2-norm in each point:</span>

<span class="sd">        &gt;&gt;&gt; x = vfspace.element([[[1, -4]],</span>
<span class="sd">        ...                      [[0, 3]]])</span>
<span class="sd">        &gt;&gt;&gt; print(pw_norm(x))</span>
<span class="sd">        [[1.0, 5.0]]</span>

<span class="sd">        We can change the exponent either in the vector field space</span>
<span class="sd">        or in the operator directly:</span>

<span class="sd">        &gt;&gt;&gt; vfspace = odl.ProductSpace(spc, 2, exponent=1)</span>
<span class="sd">        &gt;&gt;&gt; pw_norm = PointwiseNorm(vfspace)</span>
<span class="sd">        &gt;&gt;&gt; print(pw_norm(x))</span>
<span class="sd">        [[1.0, 7.0]]</span>
<span class="sd">        &gt;&gt;&gt; vfspace = odl.ProductSpace(spc, 2)</span>
<span class="sd">        &gt;&gt;&gt; pw_norm = PointwiseNorm(vfspace, exponent=1)</span>
<span class="sd">        &gt;&gt;&gt; print(pw_norm(x))</span>
<span class="sd">        [[1.0, 7.0]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vfspace</span><span class="p">,</span> <span class="n">ProductSpace</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`vfspace` </span><span class="si">{!r}</span><span class="s1"> is not a ProductSpace &#39;</span>
                            <span class="s1">&#39;instance&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vfspace</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">vfspace</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">vfspace</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                         <span class="n">base_space</span><span class="o">=</span><span class="n">vfspace</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Need to check for product space shape once higher order tensors</span>
        <span class="c1"># are implemented</span>

        <span class="k">if</span> <span class="n">exponent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">exponent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot determine `exponent` from </span><span class="si">{}</span><span class="s1">&#39;</span>
                                 <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_exponent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">exponent</span>
        <span class="k">elif</span> <span class="n">exponent</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`exponent` smaller than 1 not allowed&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_exponent</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">exponent</span><span class="p">)</span>

        <span class="c1"># Handle weighting, including sanity checks</span>
        <span class="k">if</span> <span class="n">weighting</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># TODO: find a more robust way of getting the weights as an array</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">weighting</span><span class="p">,</span> <span class="s1">&#39;array&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">array</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">weighting</span><span class="p">,</span> <span class="s1">&#39;const&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__weights</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">const</span> <span class="o">*</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;weighting scheme </span><span class="si">{!r}</span><span class="s1"> of the domain does &#39;</span>
                                 <span class="s1">&#39;not define a weighting array or constant&#39;</span>
                                 <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">weighting</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">weighting</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">weighting</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;weighting constant must be positive, got &#39;</span>
                                 <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">weighting</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__weights</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">weighting</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weighting</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">))):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;weighting array </span><span class="si">{}</span><span class="s1"> contains invalid &#39;</span>
                                 <span class="s1">&#39;entries&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">weighting</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__is_weighted</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equiv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">exponent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Exponent ``p`` of this norm.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exponent</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Weighting array of this operator.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__weights</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_weighted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;``True`` if weighting is not 1 or all ones.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__is_weighted</span>

<div class="viewcode-block" id="PointwiseNorm._call"><a class="viewcode-back" href="../../../generated/odl.operator.tensor_ops.PointwiseNorm._call.html#odl.operator.tensor_ops.PointwiseNorm._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement ``self(f, out)``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call_vecfield_1</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call_vecfield_inf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call_vecfield_p</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_call_vecfield_1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement ``self(vf, out)`` for exponent 1.&quot;&quot;&quot;</span>
        <span class="n">vf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_weighted</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">element</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">fi</span><span class="p">,</span> <span class="n">wi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vf</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">fi</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="n">tmp</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_weighted</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">*=</span> <span class="n">wi</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="n">tmp</span>

    <span class="k">def</span> <span class="nf">_call_vecfield_inf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement ``self(vf, out)`` for exponent ``inf``.&quot;&quot;&quot;</span>
        <span class="n">vf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_weighted</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">element</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">vfi</span><span class="p">,</span> <span class="n">wi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vf</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">vfi</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="n">tmp</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_weighted</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">*=</span> <span class="n">wi</span>
            <span class="n">out</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_call_vecfield_p</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement ``self(vf, out)`` for exponent 1 &lt; p &lt; ``inf``.&quot;&quot;&quot;</span>
        <span class="c1"># Optimization for 1 component - just absolute value (maybe weighted)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">vf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_weighted</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Initialize out, avoiding one copy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_abs_pow_ufunc</span><span class="p">(</span><span class="n">vf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_weighted</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">element</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">fi</span><span class="p">,</span> <span class="n">wi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vf</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_abs_pow_ufunc</span><span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">tmp</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_weighted</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">*=</span> <span class="n">wi</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="n">tmp</span>

        <span class="n">out</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_abs_pow_ufunc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute |F_i(x)|^p point-wise and write to ``out``.&quot;&quot;&quot;</span>
        <span class="c1"># Optimization for a very common case</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mf">2.0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_space</span><span class="o">.</span><span class="n">field</span> <span class="o">==</span> <span class="n">RealNumbers</span><span class="p">():</span>
            <span class="n">fi</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fi</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

<div class="viewcode-block" id="PointwiseNorm.derivative"><a class="viewcode-back" href="../../../generated/odl.operator.tensor_ops.PointwiseNorm.derivative.html#odl.operator.tensor_ops.PointwiseNorm.derivative">[docs]</a>    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Derivative of the point-wise norm operator at ``vf``.</span>

<span class="sd">        The derivative at ``F`` of the point-wise norm operator ``N``</span>
<span class="sd">        with finite exponent ``p`` and weights ``w`` is the pointwise</span>
<span class="sd">        inner product with the vector field</span>

<span class="sd">            ``x --&gt; N(F)(x)^(1-p) * [ F_j(x) * |F_j(x)|^(p-2) ]_j``.</span>

<span class="sd">        Note that this is not well-defined for ``F = 0``. If ``p &lt; 2``,</span>
<span class="sd">        any zero component will result in a singularity.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vf : `domain` `element-like`</span>
<span class="sd">            Vector field ``F`` at which to evaluate the derivative.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        deriv : `PointwiseInner`</span>
<span class="sd">            Derivative operator at the given point ``vf``.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            * if the vector field space is complex, since the derivative</span>
<span class="sd">              is not linear in that case</span>
<span class="sd">            * if the exponent is ``inf``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">field</span> <span class="o">==</span> <span class="n">ComplexNumbers</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;operator not Frechet-differentiable &#39;</span>
                                      <span class="s1">&#39;on a complex space&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;operator not Frechet-differentiable &#39;</span>
                                      <span class="s1">&#39;for exponent = inf&#39;</span><span class="p">)</span>

        <span class="n">vf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">vf</span><span class="p">)</span>
        <span class="n">vf_pwnorm_fac</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">vf</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># optimize away most common case.</span>
            <span class="n">vf_pwnorm_fac</span> <span class="o">**=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">inner_vf</span> <span class="o">=</span> <span class="n">vf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">gi</span> <span class="ow">in</span> <span class="n">inner_vf</span><span class="p">:</span>
            <span class="n">gi</span> <span class="o">/=</span> <span class="n">vf_pwnorm_fac</span> <span class="o">*</span> <span class="n">gi</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">PointwiseInner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">inner_vf</span><span class="p">,</span> <span class="n">weighting</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="PointwiseInnerBase"><a class="viewcode-back" href="../../../generated/odl.operator.tensor_ops.PointwiseInnerBase.html#odl.operator.tensor_ops.PointwiseInnerBase">[docs]</a><span class="k">class</span> <span class="nc">PointwiseInnerBase</span><span class="p">(</span><span class="n">PointwiseTensorFieldOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for `PointwiseInner` and `PointwiseInnerAdjoint`.</span>

<span class="sd">    Implemented to allow code reuse between the classes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">adjoint</span><span class="p">,</span> <span class="n">vfspace</span><span class="p">,</span> <span class="n">vecfield</span><span class="p">,</span> <span class="n">weighting</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        All parameters are given according to the specifics of the &quot;usual&quot;</span>
<span class="sd">        operator. The ``adjoint`` parameter is used to control conversions</span>
<span class="sd">        for the inverse transform.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        adjoint : bool</span>
<span class="sd">            ``True`` if the operator should be the adjoint, ``False``</span>
<span class="sd">            otherwise.</span>
<span class="sd">        vfspace : `ProductSpace`</span>
<span class="sd">            Space of vector fields on which the operator acts.</span>
<span class="sd">            It has to be a product space of identical spaces, i.e. a</span>
<span class="sd">            power space.</span>
<span class="sd">        vecfield : ``vfspace`` `element-like`</span>
<span class="sd">            Vector field with which to calculate the point-wise inner</span>
<span class="sd">            product of an input vector field</span>
<span class="sd">        weighting : `array-like` or float, optional</span>
<span class="sd">            Weighting array or constant for the norm. If an array is</span>
<span class="sd">            given, its length must be equal to ``domain.size``.</span>
<span class="sd">            By default, the weights are is taken from</span>
<span class="sd">            ``domain.weighting``. Note that this excludes unusual</span>
<span class="sd">            weightings with custom inner product, norm or dist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vfspace</span><span class="p">,</span> <span class="n">ProductSpace</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`vfsoace` </span><span class="si">{!r}</span><span class="s1"> is not a ProductSpace &#39;</span>
                            <span class="s1">&#39;instance&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vfspace</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">adjoint</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">vfspace</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">range</span><span class="o">=</span><span class="n">vfspace</span><span class="p">,</span>
                             <span class="n">base_space</span><span class="o">=</span><span class="n">vfspace</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">linear</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">vfspace</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">vfspace</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                             <span class="n">base_space</span><span class="o">=</span><span class="n">vfspace</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">linear</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Bail out if the space is complex but we cannot take the complex</span>
        <span class="c1"># conjugate.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vfspace</span><span class="o">.</span><span class="n">field</span> <span class="o">==</span> <span class="n">ComplexNumbers</span><span class="p">()</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_space</span><span class="o">.</span><span class="n">element_type</span><span class="p">,</span> <span class="s1">&#39;conj&#39;</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s1">&#39;base space element type </span><span class="si">{!r}</span><span class="s1"> does not implement conj() &#39;</span>
                <span class="s1">&#39;method required for complex inner products&#39;</span>
                <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_space</span><span class="o">.</span><span class="n">element_type</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_vecfield</span> <span class="o">=</span> <span class="n">vfspace</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">vecfield</span><span class="p">)</span>

        <span class="c1"># Handle weighting, including sanity checks</span>
        <span class="k">if</span> <span class="n">weighting</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">vfspace</span><span class="o">.</span><span class="n">weighting</span><span class="p">,</span> <span class="s1">&#39;array&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__weights</span> <span class="o">=</span> <span class="n">vfspace</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">array</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">vfspace</span><span class="o">.</span><span class="n">weighting</span><span class="p">,</span> <span class="s1">&#39;const&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__weights</span> <span class="o">=</span> <span class="p">(</span><span class="n">vfspace</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">const</span> <span class="o">*</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vfspace</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;weighting scheme </span><span class="si">{!r}</span><span class="s1"> of the domain does &#39;</span>
                                 <span class="s1">&#39;not define a weighting array or constant&#39;</span>
                                 <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vfspace</span><span class="o">.</span><span class="n">weighting</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">weighting</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__weights</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">weighting</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">vfspace</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weighting</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__is_weighted</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equiv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vecfield</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fixed vector field ``G`` of this inner product.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vecfield</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Weighting array of this operator.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__weights</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_weighted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;``True`` if weighting is not 1 or all ones.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__is_weighted</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adjoint operator.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;abstract method&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="PointwiseInner"><a class="viewcode-back" href="../../../generated/odl.operator.tensor_ops.PointwiseInner.html#odl.operator.tensor_ops.PointwiseInner">[docs]</a><span class="k">class</span> <span class="nc">PointwiseInner</span><span class="p">(</span><span class="n">PointwiseInnerBase</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Take the point-wise inner product with a given vector field.</span>

<span class="sd">    This operator takes the (weighted) inner product</span>

<span class="sd">        ``&lt;F(x), G(x)&gt; = sum_j ( w_j * F_j(x) * conj(G_j(x)) )``</span>

<span class="sd">    for a given vector field ``G``, where ``F`` is the vector field</span>
<span class="sd">    acting as a variable to this operator.</span>

<span class="sd">    This implies that the `Operator.domain` is a power space of a</span>
<span class="sd">    discretized function space. For example, if ``X`` is a `DiscreteLp`</span>
<span class="sd">    space, then ``ProductSpace(X, d)`` is a valid domain for any</span>
<span class="sd">    positive integer ``d``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vfspace</span><span class="p">,</span> <span class="n">vecfield</span><span class="p">,</span> <span class="n">weighting</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vfspace : `ProductSpace`</span>
<span class="sd">            Space of vector fields on which the operator acts.</span>
<span class="sd">            It has to be a product space of identical spaces, i.e. a</span>
<span class="sd">            power space.</span>
<span class="sd">        vecfield : ``vfspace`` `element-like`</span>
<span class="sd">            Vector field with which to calculate the point-wise inner</span>
<span class="sd">            product of an input vector field</span>
<span class="sd">        weighting : `array-like` or float, optional</span>
<span class="sd">            Weighting array or constant for the norm. If an array is</span>
<span class="sd">            given, its length must be equal to ``domain.size``, and</span>
<span class="sd">            all entries must be positive.</span>
<span class="sd">            By default, the weights are is taken from</span>
<span class="sd">            ``domain.weighting``. Note that this excludes unusual</span>
<span class="sd">            weightings with custom inner product, norm or dist.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        We make a tiny vector field space in 2D and create the</span>
<span class="sd">        point-wise inner product operator with a fixed vector field.</span>
<span class="sd">        The operator maps a vector field to a scalar function:</span>

<span class="sd">        &gt;&gt;&gt; spc = odl.uniform_discr([-1, -1], [1, 1], (1, 2))</span>
<span class="sd">        &gt;&gt;&gt; vfspace = odl.ProductSpace(spc, 2)</span>
<span class="sd">        &gt;&gt;&gt; fixed_vf = np.array([[[0, 1]],</span>
<span class="sd">        ...                      [[1, -1]]])</span>
<span class="sd">        &gt;&gt;&gt; pw_inner = PointwiseInner(vfspace, fixed_vf)</span>
<span class="sd">        &gt;&gt;&gt; pw_inner.range == spc</span>
<span class="sd">        True</span>

<span class="sd">        Now we can calculate the inner product in each point:</span>

<span class="sd">        &gt;&gt;&gt; x = vfspace.element([[[1, -4]],</span>
<span class="sd">        ...                      [[0, 3]]])</span>
<span class="sd">        &gt;&gt;&gt; print(pw_inner(x))</span>
<span class="sd">        [[0.0, -7.0]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">adjoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">vfspace</span><span class="o">=</span><span class="n">vfspace</span><span class="p">,</span> <span class="n">vecfield</span><span class="o">=</span><span class="n">vecfield</span><span class="p">,</span>
                         <span class="n">weighting</span><span class="o">=</span><span class="n">weighting</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vecfield</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fixed vector field ``G`` of this inner product.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vecfield</span>

<div class="viewcode-block" id="PointwiseInner._call"><a class="viewcode-back" href="../../../generated/odl.operator.tensor_ops.PointwiseInner._call.html#odl.operator.tensor_ops.PointwiseInner._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement ``self(vf, out)``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">field</span> <span class="o">==</span> <span class="n">ComplexNumbers</span><span class="p">():</span>
            <span class="n">vf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vecfield</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vecfield</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_weighted</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">element</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">vfi</span><span class="p">,</span> <span class="n">gi</span><span class="p">,</span> <span class="n">wi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vf</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">vecfield</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">field</span> <span class="o">==</span> <span class="n">ComplexNumbers</span><span class="p">():</span>
                <span class="n">vfi</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">gi</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">out</span><span class="o">=</span><span class="n">tmp</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vfi</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">gi</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">tmp</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_weighted</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">*=</span> <span class="n">wi</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="n">tmp</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adjoint of this operator.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adjoint : `PointwiseInnerAdjoint`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">PointwiseInnerAdjoint</span><span class="p">(</span>
            <span class="n">sspace</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_space</span><span class="p">,</span> <span class="n">vecfield</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vecfield</span><span class="p">,</span>
            <span class="n">vfspace</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">weighting</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span></div>


<div class="viewcode-block" id="PointwiseInnerAdjoint"><a class="viewcode-back" href="../../../generated/odl.operator.tensor_ops.PointwiseInnerAdjoint.html#odl.operator.tensor_ops.PointwiseInnerAdjoint">[docs]</a><span class="k">class</span> <span class="nc">PointwiseInnerAdjoint</span><span class="p">(</span><span class="n">PointwiseInnerBase</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Adjoint of the point-wise inner product operator.</span>

<span class="sd">    The adjoint of the inner product operator is a mapping</span>

<span class="sd">        ``A^* : X --&gt; X^d``.</span>

<span class="sd">    If the vector field space ``X^d`` is weighted by a vector ``v``,</span>
<span class="sd">    the adjoint, applied to a function ``h`` from ``X`` is the vector</span>
<span class="sd">    field</span>

<span class="sd">        ``x --&gt; h(x) * (w / v) * G(x)``,</span>

<span class="sd">    where ``G`` and ``w`` are the vector field and weighting from the</span>
<span class="sd">    inner product operator, resp., and all multiplications are understood</span>
<span class="sd">    component-wise.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sspace</span><span class="p">,</span> <span class="n">vecfield</span><span class="p">,</span> <span class="n">vfspace</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weighting</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sspace : `LinearSpace`</span>
<span class="sd">            &quot;Scalar&quot; space on which the operator acts</span>
<span class="sd">        vecfield : `range` `element-like`</span>
<span class="sd">            Vector field of the point-wise inner product operator</span>
<span class="sd">        vfspace : `ProductSpace`, optional</span>
<span class="sd">            Space of vector fields to which the operator maps. It must</span>
<span class="sd">            be a power space with ``sspace`` as base space.</span>
<span class="sd">            This option is intended to enforce an operator range</span>
<span class="sd">            with a certain weighting.</span>
<span class="sd">            Default: ``ProductSpace(space, len(vecfield),</span>
<span class="sd">            weighting=weighting)``</span>
<span class="sd">        weighting : `array-like` or float, optional</span>
<span class="sd">            Weighting array or constant of the inner product operator.</span>
<span class="sd">            If an array is given, its length must be equal to</span>
<span class="sd">            ``len(vecfield)``.</span>
<span class="sd">            By default, the weights are is taken from</span>
<span class="sd">            ``range.weighting`` if applicable. Note that this excludes</span>
<span class="sd">            unusual weightings with custom inner product, norm or dist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">vfspace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vfspace</span> <span class="o">=</span> <span class="n">ProductSpace</span><span class="p">(</span><span class="n">sspace</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vecfield</span><span class="p">),</span> <span class="n">weighting</span><span class="o">=</span><span class="n">weighting</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vfspace</span><span class="p">,</span> <span class="n">ProductSpace</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`vfspace` </span><span class="si">{!r}</span><span class="s1"> is not a &#39;</span>
                                <span class="s1">&#39;ProductSpace instance&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vfspace</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">vfspace</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">sspace</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;base space of the range is different from &#39;</span>
                                 <span class="s1">&#39;the given scalar space (</span><span class="si">{!r}</span><span class="s1"> != </span><span class="si">{!r}</span><span class="s1">)&#39;</span>
                                 <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vfspace</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sspace</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">adjoint</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">vfspace</span><span class="o">=</span><span class="n">vfspace</span><span class="p">,</span> <span class="n">vecfield</span><span class="o">=</span><span class="n">vecfield</span><span class="p">,</span>
                         <span class="n">weighting</span><span class="o">=</span><span class="n">weighting</span><span class="p">)</span>

        <span class="c1"># Get weighting from range</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">weighting</span><span class="p">,</span> <span class="s1">&#39;array&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ran_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">array</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">weighting</span><span class="p">,</span> <span class="s1">&#39;const&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ran_weights</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">const</span> <span class="o">*</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;weighting scheme </span><span class="si">{!r}</span><span class="s1"> of the range does &#39;</span>
                             <span class="s1">&#39;not define a weighting array or constant&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">weighting</span><span class="p">))</span>

<div class="viewcode-block" id="PointwiseInnerAdjoint._call"><a class="viewcode-back" href="../../../generated/odl.operator.tensor_ops.PointwiseInnerAdjoint._call.html#odl.operator.tensor_ops.PointwiseInnerAdjoint._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement ``self(vf, out)``.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">vfi</span><span class="p">,</span> <span class="n">oi</span><span class="p">,</span> <span class="n">ran_wi</span><span class="p">,</span> <span class="n">dom_wi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vecfield</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">__ran_weights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">):</span>
            <span class="n">vfi</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">oi</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">ran_wi</span><span class="p">,</span> <span class="n">dom_wi</span><span class="p">):</span>
                <span class="n">oi</span> <span class="o">*=</span> <span class="n">dom_wi</span> <span class="o">/</span> <span class="n">ran_wi</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adjoint of this operator.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adjoint : `PointwiseInner`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">PointwiseInner</span><span class="p">(</span><span class="n">vfspace</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="n">vecfield</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vecfield</span><span class="p">,</span>
                              <span class="n">weighting</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span></div>


<span class="c1"># TODO: Optimize this to an optimized operator on its own.</span>
<div class="viewcode-block" id="PointwiseSum"><a class="viewcode-back" href="../../../generated/odl.operator.tensor_ops.PointwiseSum.html#odl.operator.tensor_ops.PointwiseSum">[docs]</a><span class="k">class</span> <span class="nc">PointwiseSum</span><span class="p">(</span><span class="n">PointwiseInner</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Take the point-wise sum of a vector field.</span>

<span class="sd">    This operator takes the (weighted) sum</span>

<span class="sd">        ``sum(F(x)) = [ sum_j( w_j * F_j(x) ) ]</span>

<span class="sd">    where ``F`` is a vector field. This implies that</span>
<span class="sd">    the `Operator.domain` is a power space of a discretized function</span>
<span class="sd">    space. For example, if ``X`` is a `DiscreteLp` space, then</span>
<span class="sd">    ``ProductSpace(X, d)`` is a valid domain for any positive integer</span>
<span class="sd">    ``d``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vfspace</span><span class="p">,</span> <span class="n">weighting</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vfspace : `ProductSpace`</span>
<span class="sd">            Space of vector fields on which the operator acts.</span>
<span class="sd">            It has to be a product space of identical spaces, i.e. a</span>
<span class="sd">            power space.</span>
<span class="sd">        weighting : `array-like` or float, optional</span>
<span class="sd">            Weighting array or constant for the sum. If an array is</span>
<span class="sd">            given, its length must be equal to ``domain.size``.</span>
<span class="sd">            By default, the weights are is taken from</span>
<span class="sd">            ``domain.weighting``. Note that this excludes unusual</span>
<span class="sd">            weightings with custom inner product, norm or dist.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        We make a tiny vector field space in 2D and create the</span>
<span class="sd">        standard point-wise sum operator on that space. The operator</span>
<span class="sd">        maps a vector field to a scalar function:</span>

<span class="sd">        &gt;&gt;&gt; spc = odl.uniform_discr([-1, -1], [1, 1], (1, 2))</span>
<span class="sd">        &gt;&gt;&gt; vfspace = odl.ProductSpace(spc, 2)</span>
<span class="sd">        &gt;&gt;&gt; pw_sum = PointwiseSum(vfspace)</span>
<span class="sd">        &gt;&gt;&gt; pw_sum.range == spc</span>
<span class="sd">        True</span>

<span class="sd">        Now we can calculate the sum in each point:</span>

<span class="sd">        &gt;&gt;&gt; x = vfspace.element([[[1, -4]],</span>
<span class="sd">        ...                      [[0, 3]]])</span>
<span class="sd">        &gt;&gt;&gt; print(pw_sum(x))</span>
<span class="sd">        [[1.0, -1.0]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vfspace</span><span class="p">,</span> <span class="n">ProductSpace</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`vfspace` </span><span class="si">{!r}</span><span class="s1"> is not a ProductSpace &#39;</span>
                            <span class="s1">&#39;instance&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vfspace</span><span class="p">))</span>

        <span class="n">ones</span> <span class="o">=</span> <span class="n">vfspace</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">vfspace</span><span class="p">,</span> <span class="n">vecfield</span><span class="o">=</span><span class="n">ones</span><span class="p">,</span> <span class="n">weighting</span><span class="o">=</span><span class="n">weighting</span><span class="p">)</span></div>


<div class="viewcode-block" id="MatrixOperator"><a class="viewcode-back" href="../../../generated/odl.operator.tensor_ops.MatrixOperator.html#odl.operator.tensor_ops.MatrixOperator">[docs]</a><span class="k">class</span> <span class="nc">MatrixOperator</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Matrix-vector multiplication as a linear operator.</span>

<span class="sd">    This operator uses a matrix to represent an operator, and get its</span>
<span class="sd">    adjoint and inverse by doing computations on the matrix. This is in</span>
<span class="sd">    general a rather slow and memory-inefficient approach, and users are</span>
<span class="sd">    recommended to use other alternatives if possible.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix : `array-like` or `scipy.sparse.base.spmatrix`</span>
<span class="sd">            2-dimensional array representing the linear operator.</span>
<span class="sd">        domain : `FnBase`, optional</span>
<span class="sd">            Space of elements on which the operator can act. Its</span>
<span class="sd">            ``dtype`` must be castable to ``range.dtype``.</span>
<span class="sd">            For the default ``None``, a `NumpyFn` space with size</span>
<span class="sd">            ``matrix.shape[1]`` is used, together with the matrix&#39;</span>
<span class="sd">            data type.</span>
<span class="sd">        range : `FnBase`, optional</span>
<span class="sd">            Space of elements on to which the operator maps. Its</span>
<span class="sd">            ``shape`` and ``dtype`` attributes must match the ones</span>
<span class="sd">            of the result of the multiplication.</span>
<span class="sd">            For the default ``None``, the range is inferred from</span>
<span class="sd">            ``matrix`` and ``domain``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        By default, ``domain`` and ``range`` are `NumpyFn` type spaces:</span>

<span class="sd">        &gt;&gt;&gt; matrix = np.ones((3, 4))</span>
<span class="sd">        &gt;&gt;&gt; op = MatrixOperator(matrix)</span>
<span class="sd">        &gt;&gt;&gt; op</span>
<span class="sd">        MatrixOperator(</span>
<span class="sd">            [[ 1.,  1.,  1.,  1.],</span>
<span class="sd">             [ 1.,  1.,  1.,  1.],</span>
<span class="sd">             [ 1.,  1.,  1.,  1.]]</span>
<span class="sd">        )</span>
<span class="sd">        &gt;&gt;&gt; op.domain</span>
<span class="sd">        rn(4)</span>
<span class="sd">        &gt;&gt;&gt; op.range</span>
<span class="sd">        rn(3)</span>
<span class="sd">        &gt;&gt;&gt; op([1, 2, 3, 4])</span>
<span class="sd">        rn(3).element([10.0, 10.0, 10.0])</span>

<span class="sd">        They can also be provided explicitly, for example with</span>
<span class="sd">        `uniform_discr` spaces:</span>

<span class="sd">        &gt;&gt;&gt; dom = odl.uniform_discr(0, 1, 4)</span>
<span class="sd">        &gt;&gt;&gt; ran = odl.uniform_discr(0, 1, 3)</span>
<span class="sd">        &gt;&gt;&gt; op = MatrixOperator(matrix, domain=dom, range=ran)</span>
<span class="sd">        &gt;&gt;&gt; op(dom.one())</span>
<span class="sd">        uniform_discr(0.0, 1.0, 3).element([4.0, 4.0, 4.0])</span>

<span class="sd">        For storage efficiency, SciPy sparse matrices can be used:</span>

<span class="sd">        &gt;&gt;&gt; import scipy</span>
<span class="sd">        &gt;&gt;&gt; row_idcs = np.array([0, 3, 1, 0])</span>
<span class="sd">        &gt;&gt;&gt; col_idcs = np.array([0, 3, 1, 2])</span>
<span class="sd">        &gt;&gt;&gt; values = np.array([4.0, 5.0, 7.0, 9.0])</span>
<span class="sd">        &gt;&gt;&gt; matrix = scipy.sparse.coo_matrix((values, (row_idcs, col_idcs)),</span>
<span class="sd">        ...                                  shape=(4, 4))</span>
<span class="sd">        &gt;&gt;&gt; matrix.toarray()</span>
<span class="sd">        array([[ 4.,  0.,  9.,  0.],</span>
<span class="sd">               [ 0.,  7.,  0.,  0.],</span>
<span class="sd">               [ 0.,  0.,  0.,  0.],</span>
<span class="sd">               [ 0.,  0.,  0.,  5.]])</span>
<span class="sd">        &gt;&gt;&gt; op = MatrixOperator(matrix)</span>
<span class="sd">        &gt;&gt;&gt; op(op.domain.one())</span>
<span class="sd">        rn(4).element([13.0, 7.0, 0.0, 5.0])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: fix dead link `scipy.sparse.spmatrix`</span>
        <span class="k">if</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">isspmatrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span> <span class="o">=</span> <span class="n">matrix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;matrix </span><span class="si">{}</span><span class="s1"> has </span><span class="si">{}</span><span class="s1"> axes instead of 2&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

        <span class="c1"># Infer domain and range from matrix if necessary</span>
        <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">domain</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">FnBase</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`domain` </span><span class="si">{!r}</span><span class="s1"> is not an `FnBase` instance&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">domain</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">range</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">range</span><span class="p">,</span> <span class="n">FnBase</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`range` </span><span class="si">{!r}</span><span class="s1"> is not an `FnBase` instance&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">range</span><span class="p">))</span>

        <span class="c1"># Check compatibility of matrix with domain and range</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="nb">range</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">domain</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;matrix shape </span><span class="si">{}</span><span class="s1"> does not match the required &#39;</span>
                             <span class="s1">&#39;shape </span><span class="si">{}</span><span class="s1"> of a matrix </span><span class="si">{}</span><span class="s1"> --&gt; </span><span class="si">{}</span><span class="s1">&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                       <span class="p">(</span><span class="nb">range</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">domain</span><span class="o">.</span><span class="n">size</span><span class="p">),</span>
                                       <span class="n">domain</span><span class="p">,</span> <span class="nb">range</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">range</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;domain data type </span><span class="si">{!r}</span><span class="s1"> cannot be safely cast to &#39;</span>
                            <span class="s1">&#39;range data type </span><span class="si">{!r}</span><span class="s1">&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">range</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">range</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;matrix data type </span><span class="si">{!r}</span><span class="s1"> cannot be safely cast to &#39;</span>
                            <span class="s1">&#39;range data type </span><span class="si">{!r}</span><span class="s1">.&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">range</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Matrix representing this operator.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">matrix_issparse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Whether the representing matrix is sparse or not.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">isspmatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adjoint operator represented by the adjoint matrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adjoint : `MatrixOperator`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">field</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">field</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;adjoint not defined since fields &#39;</span>
                                      <span class="s1">&#39;of domain and range differ (</span><span class="si">{}</span><span class="s1"> != </span><span class="si">{}</span><span class="s1">)&#39;</span>
                                      <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">field</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">field</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">MatrixOperator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                              <span class="n">domain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inverse operator represented by the inverse matrix.</span>

<span class="sd">        Taking the inverse causes sparse matrices to become dense and is</span>
<span class="sd">        generally very heavy computationally since the matrix is inverted</span>
<span class="sd">        numerically (an O(n^3) operation). It is recommended to instead</span>
<span class="sd">        use one of the solvers available in the ``odl.solvers`` package.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inverse : `MatrixOperator`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix_issparse</span><span class="p">:</span>
            <span class="n">dense_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dense_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span>
        <span class="k">return</span> <span class="n">MatrixOperator</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">dense_matrix</span><span class="p">),</span>
                              <span class="n">domain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>

<div class="viewcode-block" id="MatrixOperator._call"><a class="viewcode-back" href="../../../generated/odl.operator.tensor_ops.MatrixOperator._call.html#odl.operator.tensor_ops.MatrixOperator._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raw apply method on input, writing to given output.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix_issparse</span><span class="p">:</span>
                <span class="c1"># Unfortunately, there is no native in-place dot product for</span>
                <span class="c1"># sparse matrices</span>
                <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">writable_array</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="k">as</span> <span class="n">out_arr</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out_arr</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="c1"># Matrix printing itself in an executable way (for dense matrix)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix_issparse</span><span class="p">:</span>
            <span class="c1"># Don&#39;t convert to dense, can take forever</span>
            <span class="n">matrix_str</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">matrix_str</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s1">&#39;, &#39;</span><span class="p">)</span>
        <span class="n">posargs</span> <span class="o">=</span> <span class="p">[</span><span class="n">matrix_str</span><span class="p">]</span>

        <span class="c1"># Optional arguments with defaults, inferred from the matrix</span>
        <span class="n">optargs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># domain</span>
        <span class="n">optargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">(</span><span class="s1">&#39;domain&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="c1"># range</span>
        <span class="n">optargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">(</span><span class="s1">&#39;range&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
        <span class="p">)</span>

        <span class="n">inner_str</span> <span class="o">=</span> <span class="n">signature_string</span><span class="p">(</span><span class="n">posargs</span><span class="p">,</span> <span class="n">optargs</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;, &#39;</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="p">,</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">],</span>
                                     <span class="n">mod</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;!s&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;!r&#39;</span><span class="p">,</span> <span class="s1">&#39;!r&#39;</span><span class="p">]])</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                   <span class="n">indent_rows</span><span class="p">(</span><span class="n">inner_str</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``str(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># pylint: disable=wrong-import-position</span>
    <span class="kn">from</span> <span class="nn">odl.util.testutils</span> <span class="k">import</span> <span class="n">run_doctests</span>
    <span class="n">run_doctests</span><span class="p">()</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-2017, ODL development group.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.6.1.dev0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>