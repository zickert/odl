

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>odl.space.pspace &mdash; odl 0.6.1.dev0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="odl 0.6.1.dev0 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> odl
          

          
          </a>

          
            
            
              <div class="version">
                0.6.1.dev0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/getting_started.html">Getting Started</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with ODL</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/guide.html">User&#8217;s guide &#8211; selected topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../math/math.html">Mathematical Background</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer zone</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../dev/dev.html">Contributing to ODL</a></li>
</ul>
<p class="caption"><span class="caption-text">Useful facts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/faq.html">Frequently asked questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release_notes.html">Release Notes</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../refs.html">References</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../odl.html">odl</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">odl</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>odl.space.pspace</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for odl.space.pspace</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2014-2017 The ODL contributors</span>
<span class="c1">#</span>
<span class="c1"># This file is part of ODL.</span>
<span class="c1">#</span>
<span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public License,</span>
<span class="c1"># v. 2.0. If a copy of the MPL was not distributed with this file, You can</span>
<span class="c1"># obtain one at https://mozilla.org/MPL/2.0/.</span>

<span class="sd">&quot;&quot;&quot;Cartesian products of `LinearSpace` instances.&quot;&quot;&quot;</span>

<span class="c1"># Imports for common Python 2/3 codebase</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="k">import</span> <span class="nb">range</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">super</span><span class="p">,</span> <span class="nb">zip</span>
<span class="kn">from</span> <span class="nn">future</span> <span class="k">import</span> <span class="n">standard_library</span>
<span class="n">standard_library</span><span class="o">.</span><span class="n">install_aliases</span><span class="p">()</span>

<span class="kn">from</span> <span class="nn">numbers</span> <span class="k">import</span> <span class="n">Integral</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">product</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">odl.set</span> <span class="k">import</span> <span class="n">LinearSpace</span><span class="p">,</span> <span class="n">LinearSpaceElement</span><span class="p">,</span> <span class="n">RealNumbers</span>
<span class="kn">from</span> <span class="nn">odl.space.weighting</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">Weighting</span><span class="p">,</span> <span class="n">ArrayWeighting</span><span class="p">,</span> <span class="n">ConstWeighting</span><span class="p">,</span> <span class="n">NoWeighting</span><span class="p">,</span>
    <span class="n">CustomInner</span><span class="p">,</span> <span class="n">CustomNorm</span><span class="p">,</span> <span class="n">CustomDist</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">odl.util</span> <span class="k">import</span> <span class="n">is_real_dtype</span><span class="p">,</span> <span class="n">signature_string</span><span class="p">,</span> <span class="n">indent_rows</span>
<span class="kn">from</span> <span class="nn">odl.util.ufuncs</span> <span class="k">import</span> <span class="n">ProductSpaceUfuncs</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;ProductSpace&#39;</span><span class="p">,</span> <span class="s1">&#39;ProductSpaceElement&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="ProductSpace"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpace.html#odl.space.pspace.ProductSpace">[docs]</a><span class="k">class</span> <span class="nc">ProductSpace</span><span class="p">(</span><span class="n">LinearSpace</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Cartesian product of `LinearSpace`&#39;s.</span>

<span class="sd">    A product space is the Cartesian product ``X_1 x ... x X_n`` of</span>
<span class="sd">    linear spaces ``X_i``. It is itself a linear space, where the linear</span>
<span class="sd">    combination is defined component-wise. Inner product, norm and</span>
<span class="sd">    distance can also be defined in natural ways from the corresponding</span>
<span class="sd">    functions in the individual components.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">spaces</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        space1,...,spaceN : `LinearSpace` or int</span>
<span class="sd">            The individual spaces (&quot;factors / parts&quot;) in the product</span>
<span class="sd">            space. Can also be given as ``space, n`` with ``n`` integer,</span>
<span class="sd">            in which case the power space ``space ** n`` is created.</span>
<span class="sd">        exponent : non-zero float or ``float(&#39;inf&#39;)``, optional</span>
<span class="sd">            Order of the product distance/norm, i.e.</span>

<span class="sd">            ``dist(x, y) = np.linalg.norm(x-y, ord=exponent)``</span>

<span class="sd">            ``norm(x) = np.linalg.norm(x, ord=exponent)``</span>

<span class="sd">            Values ``0 &lt;= exponent &lt; 1`` are currently unsupported</span>
<span class="sd">            due to numerical instability. See ``Notes`` for further</span>
<span class="sd">            information about the interpretation of the values.</span>

<span class="sd">            Default: 2.0</span>

<span class="sd">        field : `Field`, optional</span>
<span class="sd">            Scalar field of the resulting space.</span>
<span class="sd">            Default: ``spaces[0].field``</span>

<span class="sd">        weighting : optional</span>
<span class="sd">            Use weighted inner product, norm, and dist. The following</span>
<span class="sd">            types are supported as ``weighting``:</span>

<span class="sd">            ``None`` : no weighting (default)</span>

<span class="sd">            `Weighting` : weighting class, used directly. Such a</span>
<span class="sd">            class instance can be retrieved from the space by the</span>
<span class="sd">            `ProductSpace.weighting` property.</span>

<span class="sd">            `array-like` : weigh each component with one entry from the</span>
<span class="sd">            array. The array must be one-dimensional and have the same</span>
<span class="sd">            length as the number of spaces.</span>

<span class="sd">            float : same weighting factor in each component</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        dist : callable, optional</span>
<span class="sd">            The distance function defining a metric on the space.</span>
<span class="sd">            It must accept two `ProductSpaceElement` arguments and</span>
<span class="sd">            fulfill the following mathematical conditions for any</span>
<span class="sd">            three space elements ``x, y, z``:</span>

<span class="sd">            - ``dist(x, y) &gt;= 0``</span>
<span class="sd">            - ``dist(x, y) = 0``  if and only if  ``x = y``</span>
<span class="sd">            - ``dist(x, y) = dist(y, x)``</span>
<span class="sd">            - ``dist(x, y) &lt;= dist(x, z) + dist(z, y)``</span>

<span class="sd">            By default, ``dist(x, y)`` is calculated as ``norm(x - y)``.</span>
<span class="sd">            This creates an intermediate array ``x - y``, which can be</span>
<span class="sd">            avoided by choosing ``dist_using_inner=True``.</span>

<span class="sd">            Cannot be combined with: ``weighting, norm, inner``</span>

<span class="sd">        norm : callable, optional</span>
<span class="sd">            The norm implementation. It must accept an</span>
<span class="sd">            `ProductSpaceElement` argument, return a float and satisfy the</span>
<span class="sd">            following conditions for all space elements ``x, y`` and scalars</span>
<span class="sd">            ``s``:</span>

<span class="sd">            - ``||x|| &gt;= 0``</span>
<span class="sd">            - ``||x|| = 0``  if and only if  ``x = 0``</span>
<span class="sd">            - ``||s * x|| = |s| * ||x||``</span>
<span class="sd">            - ``||x + y|| &lt;= ||x|| + ||y||``</span>

<span class="sd">            By default, ``norm(x)`` is calculated as ``inner(x, x)``.</span>

<span class="sd">            Cannot be combined with: ``weighting, dist, inner``</span>

<span class="sd">        inner : callable, optional</span>
<span class="sd">            The inner product implementation. It must accept two</span>
<span class="sd">            `ProductSpaceElement` arguments, return a element from</span>
<span class="sd">            the field of the space (real or complex number) and</span>
<span class="sd">            satisfy the following conditions for all space elements</span>
<span class="sd">            ``x, y, z`` and scalars ``s``:</span>

<span class="sd">            - ``&lt;x, y&gt; = conj(&lt;y, x&gt;)``</span>
<span class="sd">            - ``&lt;s*x + y, z&gt; = s * &lt;x, z&gt; + &lt;y, z&gt;``</span>
<span class="sd">            - ``&lt;x, x&gt; = 0``  if and only if  ``x = 0``</span>

<span class="sd">            Cannot be combined with: ``weighting, dist, norm``</span>

<span class="sd">        dist_using_inner : bool, optional</span>
<span class="sd">            Calculate ``dist`` using the formula</span>

<span class="sd">                ``||x - y||^2 = ||x||^2 + ||y||^2 - 2 * Re &lt;x, y&gt;``</span>

<span class="sd">            This avoids the creation of new arrays and is thus faster</span>
<span class="sd">            for large arrays. On the downside, it will not evaluate to</span>
<span class="sd">            exactly zero for equal (but not identical) ``x`` and ``y``.</span>

<span class="sd">            This option can only be used if ``exponent`` is 2.0.</span>

<span class="sd">            Default: ``False``.</span>

<span class="sd">            Cannot be combined with: ``dist``</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Product of two rn spaces</span>

<span class="sd">        &gt;&gt;&gt; r2x3 = ProductSpace(odl.rn(2), odl.rn(3))</span>

<span class="sd">        Powerspace of rn space</span>

<span class="sd">        &gt;&gt;&gt; r2x2x2 = ProductSpace(odl.rn(2), 3)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Inner product, norm and distance are evaluated by collecting</span>
<span class="sd">        the result of the corresponding operation in the individual</span>
<span class="sd">        components and reducing the resulting vector to a single number.</span>
<span class="sd">        The ``exponent`` parameter influences only this last part,</span>
<span class="sd">        not the computations in the individual components. We give the</span>
<span class="sd">        exact definitions in the following:</span>

<span class="sd">        Let :math:`\mathcal{X} = \mathcal{X}_1 \\times \dots \\times</span>
<span class="sd">        \mathcal{X}_d` be a product space, and</span>
<span class="sd">        :math:`\langle \cdot, \cdot\\rangle_i`,</span>
<span class="sd">        :math:`\lVert \cdot \\rVert_i`, :math:`d_i(\cdot, \cdot)` be</span>
<span class="sd">        inner products, norms and distances in the respective</span>
<span class="sd">        component spaces.</span>

<span class="sd">        **Inner product:**</span>

<span class="sd">        .. math::</span>
<span class="sd">            \langle x, y \\rangle = \\sum_{i=1}^d \langle x_i, y_i \\rangle_i</span>

<span class="sd">        **Norm:**</span>

<span class="sd">        - :math:`p &lt; \infty`:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \lVert x\\rVert =</span>
<span class="sd">            \left( \sum_{i=1}^d \lVert x_i \\rVert_i^p \\right)^{1/p}</span>

<span class="sd">        - :math:`p = \infty`:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \lVert x\\rVert = \max_i \lVert x_i \\rVert_i</span>

<span class="sd">        **Distance:**</span>

<span class="sd">        - :math:`p &lt; \infty`:</span>

<span class="sd">        .. math::</span>
<span class="sd">            d(x, y) = \left( \sum_{i=1}^d d_i(x_i, y_i)^p \\right)^{1/p}</span>

<span class="sd">        - :math:`p = \infty`:</span>

<span class="sd">        .. math::</span>
<span class="sd">            d(x, y) = \max_i d_i(x_i, y_i)</span>

<span class="sd">        To implement own versions of these functions, you can use</span>
<span class="sd">        the following snippet to gather the vector of norms (analogously</span>
<span class="sd">        for inner products and distances)::</span>

<span class="sd">            norms = np.fromiter(</span>
<span class="sd">                (xi.norm() for xi in x),</span>
<span class="sd">                dtype=np.float64, count=len(x))</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ProductSpaceArrayWeighting</span>
<span class="sd">        ProductSpaceConstWeighting</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dist&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">inner</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;inner&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">weighting</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;weighting&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">exponent</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;exponent&#39;</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">))</span>
        <span class="n">dist_using_inner</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dist_using_inner&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;got unexpected keyword arguments: </span><span class="si">{}</span><span class="s1">&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="c1"># Check validity of option combination (3 or 4 out of 4 must be None)</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">inner</span><span class="p">,</span> <span class="n">weighting</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid combination of options weighting, &#39;</span>
                             <span class="s1">&#39;dist, norm and inner&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">inner</span><span class="p">))</span> <span class="ow">and</span> <span class="n">exponent</span> <span class="o">!=</span> <span class="mf">2.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`exponent` cannot be used together with &#39;</span>
                             <span class="s1">&#39;inner, norm or dist&#39;</span><span class="p">)</span>

        <span class="c1"># Make a power space if the second argument is an integer</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spaces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">LinearSpace</span><span class="p">)</span> <span class="ow">and</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">spaces</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Integral</span><span class="p">)):</span>
            <span class="n">spaces</span> <span class="o">=</span> <span class="p">[</span><span class="n">spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">spaces</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Validate the space arguments</span>
        <span class="n">wrong_spaces</span> <span class="o">=</span> <span class="p">[</span><span class="n">spc</span> <span class="k">for</span> <span class="n">spc</span> <span class="ow">in</span> <span class="n">spaces</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spc</span><span class="p">,</span> <span class="n">LinearSpace</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">wrong_spaces</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1"> not LinearSpace instance(s)&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">wrong_spaces</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">spc</span><span class="o">.</span><span class="n">field</span> <span class="o">==</span> <span class="n">spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">field</span> <span class="k">for</span> <span class="n">spc</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;all spaces must have the same field&#39;</span><span class="p">)</span>

        <span class="c1"># Assign spaces and field</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__spaces</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">spaces</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spaces</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;no spaces provided, cannot deduce field&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">field</span>

        <span class="c1"># Cache for efficiency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__is_power_space</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">spc</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                    <span class="k">for</span> <span class="n">spc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>

        <span class="c1"># Assign weighting</span>
        <span class="k">if</span> <span class="n">weighting</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weighting</span><span class="p">,</span> <span class="n">Weighting</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__weighting</span> <span class="o">=</span> <span class="n">weighting</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">weighting</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__weighting</span> <span class="o">=</span> <span class="n">ProductSpaceConstWeighting</span><span class="p">(</span>
                    <span class="n">weighting</span><span class="p">,</span> <span class="n">exponent</span><span class="p">,</span> <span class="n">dist_using_inner</span><span class="o">=</span><span class="n">dist_using_inner</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">weighting</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Need to wait until dist, norm and inner are handled</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># last possibility: make a product space element</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weighting</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">object</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid weighting argument </span><span class="si">{}</span><span class="s1">&#39;</span>
                                     <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">weighting</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__weighting</span> <span class="o">=</span> <span class="n">ProductSpaceArrayWeighting</span><span class="p">(</span>
                        <span class="n">arr</span><span class="p">,</span> <span class="n">exponent</span><span class="p">,</span> <span class="n">dist_using_inner</span><span class="o">=</span><span class="n">dist_using_inner</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;weighting array has </span><span class="si">{}</span><span class="s1"> dimensions, &#39;</span>
                                     <span class="s1">&#39;expected 1&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">dist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__weighting</span> <span class="o">=</span> <span class="n">ProductSpaceCustomDist</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__weighting</span> <span class="o">=</span> <span class="n">ProductSpaceCustomNorm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">inner</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__weighting</span> <span class="o">=</span> <span class="n">ProductSpaceCustomInner</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># all None -&gt; no weighing</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__weighting</span> <span class="o">=</span> <span class="n">ProductSpaceNoWeighting</span><span class="p">(</span>
                <span class="n">exponent</span><span class="p">,</span> <span class="n">dist_using_inner</span><span class="o">=</span><span class="n">dist_using_inner</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of factors.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__size</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``len(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of spaces per axis.&quot;&quot;&quot;</span>
        <span class="c1"># Currently supporting only 1d product spaces</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spaces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A tuple containing all spaces.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spaces</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_power_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;``True`` if all member spaces are equal.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__is_power_space</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">exponent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Exponent of the product space norm/dist, ``None`` for custom.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">exponent</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">weighting</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This space&#39;s weighting scheme.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__weighting</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_weighted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``True`` if weighting is not `ProductSpaceNoWeighting`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="p">,</span> <span class="n">ProductSpaceNoWeighting</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The data type of this space.</span>

<span class="sd">        This is only well defined if all subspaces have the same dtype.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AttributeError</span>
<span class="sd">            If any of the subspaces does not implement `dtype` or if the dtype</span>
<span class="sd">            of the subspaces does not match.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">space</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">dtypes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="n">dtypes</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">dtypes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;`dtype`&#39;s of subspaces not equal&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="ProductSpace.element"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpace.element.html#odl.space.pspace.ProductSpace.element">[docs]</a>    <span class="k">def</span> <span class="nf">element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cast</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an element in the product space.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inp : optional</span>
<span class="sd">            If ``inp`` is ``None``, a new element is created from</span>
<span class="sd">            scratch by allocation in the spaces. If ``inp`` is</span>
<span class="sd">            already an element of this space, it is re-wrapped.</span>
<span class="sd">            Otherwise, a new element is created from the</span>
<span class="sd">            components by calling the ``element()`` methods</span>
<span class="sd">            in the component spaces.</span>
<span class="sd">        cast : bool, optional</span>
<span class="sd">            If ``True``, casting is allowed. Otherwise, a ``TypeError``</span>
<span class="sd">            is raised for input that is not a sequence of elements of</span>
<span class="sd">            the spaces that make up this product space.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        element : `ProductSpaceElement`</span>
<span class="sd">            The new element</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; r2, r3 = odl.rn(2), odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; vec_2, vec_3 = r2.element(), r3.element()</span>
<span class="sd">        &gt;&gt;&gt; r2x3 = ProductSpace(r2, r3)</span>
<span class="sd">        &gt;&gt;&gt; vec_2x3 = r2x3.element()</span>
<span class="sd">        &gt;&gt;&gt; vec_2.space == vec_2x3[0].space</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; vec_3.space == vec_2x3[1].space</span>
<span class="sd">        True</span>

<span class="sd">        Create an element of the product space</span>

<span class="sd">        &gt;&gt;&gt; r2, r3 = odl.rn(2), odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; prod = ProductSpace(r2, r3)</span>
<span class="sd">        &gt;&gt;&gt; x2 = r2.element([1, 2])</span>
<span class="sd">        &gt;&gt;&gt; x3 = r3.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; x = prod.element([x2, x3])</span>
<span class="sd">        &gt;&gt;&gt; print(x)</span>
<span class="sd">        {[1.0, 2.0], [1.0, 2.0, 3.0]}</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If data is given as keyword arg, prefer it over arg list</span>
        <span class="k">if</span> <span class="n">inp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inp</span> <span class="o">=</span> <span class="p">[</span><span class="n">space</span><span class="o">.</span><span class="n">element</span><span class="p">()</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">inp</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">inp</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;length of `inp` </span><span class="si">{}</span><span class="s1"> does not match length of &#39;</span>
                             <span class="s1">&#39;space </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inp</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">LinearSpaceElement</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">space</span> <span class="o">==</span> <span class="n">space</span>
                <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">space</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">))):</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cast</span><span class="p">:</span>
            <span class="c1"># Delegate constructors</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="p">[</span><span class="n">space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">space</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;input </span><span class="si">{!r}</span><span class="s1"> not a sequence of elements of the &#39;</span>
                            <span class="s1">&#39;component spaces&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inp</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parts</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">examples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return examples from all sub-spaces.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">examples</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">spc</span><span class="o">.</span><span class="n">examples</span> <span class="k">for</span> <span class="n">spc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">]):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">examples</span><span class="p">)</span>
            <span class="n">element</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">([</span><span class="n">elem</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">examples</span><span class="p">])</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>

<div class="viewcode-block" id="ProductSpace.zero"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpace.zero.html#odl.space.pspace.ProductSpace.zero">[docs]</a>    <span class="k">def</span> <span class="nf">zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create the zero element of the product space.</span>

<span class="sd">        The i-th component of the product space zero element is the</span>
<span class="sd">        zero element of the i-th space in the product.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        zero : ProductSpaceElement</span>
<span class="sd">            The zero element in the product space.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; r2, r3 = odl.rn(2), odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; zero_2, zero_3 = r2.zero(), r3.zero()</span>
<span class="sd">        &gt;&gt;&gt; r2x3 = ProductSpace(r2, r3)</span>
<span class="sd">        &gt;&gt;&gt; zero_2x3 = r2x3.zero()</span>
<span class="sd">        &gt;&gt;&gt; zero_2 == zero_2x3[0]</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; zero_3 == zero_2x3[1]</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">([</span><span class="n">space</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">])</span></div>

<div class="viewcode-block" id="ProductSpace.one"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpace.one.html#odl.space.pspace.ProductSpace.one">[docs]</a>    <span class="k">def</span> <span class="nf">one</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create the one element of the product space.</span>

<span class="sd">        The i-th component of the product space one element is the</span>
<span class="sd">        one element of the i-th space in the product.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        one : ProductSpaceElement</span>
<span class="sd">            The one element in the product space.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; r2, r3 = odl.rn(2), odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; one_2, one_3 = r2.one(), r3.one()</span>
<span class="sd">        &gt;&gt;&gt; r2x3 = ProductSpace(r2, r3)</span>
<span class="sd">        &gt;&gt;&gt; one_2x3 = r2x3.one()</span>
<span class="sd">        &gt;&gt;&gt; one_2 == one_2x3[0]</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; one_3 == one_2x3[1]</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">([</span><span class="n">space</span><span class="o">.</span><span class="n">one</span><span class="p">()</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">])</span></div>

<div class="viewcode-block" id="ProductSpace._lincomb"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpace._lincomb.html#odl.space.pspace.ProductSpace._lincomb">[docs]</a>    <span class="k">def</span> <span class="nf">_lincomb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Linear combination ``out = a*x + b*y``.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">space</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span> <span class="n">outp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span>
                                       <span class="n">out</span><span class="o">.</span><span class="n">parts</span><span class="p">):</span>
            <span class="n">space</span><span class="o">.</span><span class="n">_lincomb</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span> <span class="n">outp</span><span class="p">)</span></div>

<div class="viewcode-block" id="ProductSpace._dist"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpace._dist.html#odl.space.pspace.ProductSpace._dist">[docs]</a>    <span class="k">def</span> <span class="nf">_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Distance between two elements.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">dist</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span></div>

<div class="viewcode-block" id="ProductSpace._norm"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpace._norm.html#odl.space.pspace.ProductSpace._norm">[docs]</a>    <span class="k">def</span> <span class="nf">_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Norm of an element.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="ProductSpace._inner"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpace._inner.html#odl.space.pspace.ProductSpace._inner">[docs]</a>    <span class="k">def</span> <span class="nf">_inner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inner product of two elements.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span></div>

<div class="viewcode-block" id="ProductSpace._multiply"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpace._multiply.html#odl.space.pspace.ProductSpace._multiply">[docs]</a>    <span class="k">def</span> <span class="nf">_multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Product ``out = x1 * x2``.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">spc</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span> <span class="n">outp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">,</span> <span class="n">x1</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">x2</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span>
                                     <span class="n">out</span><span class="o">.</span><span class="n">parts</span><span class="p">):</span>
            <span class="n">spc</span><span class="o">.</span><span class="n">_multiply</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span> <span class="n">outp</span><span class="p">)</span></div>

<div class="viewcode-block" id="ProductSpace._divide"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpace._divide.html#odl.space.pspace.ProductSpace._divide">[docs]</a>    <span class="k">def</span> <span class="nf">_divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Quotient ``out = x1 / x2``.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">spc</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span> <span class="n">outp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">,</span> <span class="n">x1</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">x2</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span>
                                     <span class="n">out</span><span class="o">.</span><span class="n">parts</span><span class="p">):</span>
            <span class="n">spc</span><span class="o">.</span><span class="n">_divide</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span> <span class="n">outp</span><span class="p">)</span></div>

<div class="viewcode-block" id="ProductSpace.__eq__"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpace.__eq__.html#odl.space.pspace.ProductSpace.__eq__">[docs]</a>    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self == other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        equals : bool</span>
<span class="sd">            ``True`` if ``other`` is a `ProductSpace` instance, has</span>
<span class="sd">            the same length and the same factors. ``False`` otherwise.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; r2, r3 = odl.rn(2), odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; rn, rm = odl.rn(2), odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; r2x3, rnxm = ProductSpace(r2, r3), ProductSpace(rn, rm)</span>
<span class="sd">        &gt;&gt;&gt; r2x3 == rnxm</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; r3x2 = ProductSpace(r3, r2)</span>
<span class="sd">        &gt;&gt;&gt; r2x3 == r3x2</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; r5 = ProductSpace(*[odl.rn(1)]*5)</span>
<span class="sd">        &gt;&gt;&gt; r2x3 == r5</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; r5 = odl.rn(5)</span>
<span class="sd">        &gt;&gt;&gt; r2x3 == r5</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ProductSpace</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">weighting</span> <span class="ow">and</span>
                    <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">,</span>
                                               <span class="n">other</span><span class="o">.</span><span class="n">spaces</span><span class="p">)))</span></div>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``hash(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="p">))</span>

<div class="viewcode-block" id="ProductSpace.__getitem__"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpace.__getitem__.html#odl.space.pspace.ProductSpace.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self[indices]``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ProductSpace</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span>
                                <span class="n">field</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ProductSpace</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">],</span>
                                <span class="n">field</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``str(self)``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">space</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;{&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;}^&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39; x &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">space</span><span class="p">)</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="n">weight_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">repr_part</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">posargs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">optargs</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
            <span class="n">oneline</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_power_space</span><span class="p">:</span>
            <span class="n">posargs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
            <span class="n">optargs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">oneline</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">posargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span>
            <span class="n">optargs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">argstr</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">)</span>
            <span class="n">oneline</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">argstr</span> <span class="o">+</span> <span class="n">weight_str</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">40</span> <span class="ow">and</span>
                       <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">argstr</span> <span class="o">+</span> <span class="n">weight_str</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">oneline</span><span class="p">:</span>
            <span class="n">inner_str</span> <span class="o">=</span> <span class="n">signature_string</span><span class="p">(</span><span class="n">posargs</span><span class="p">,</span> <span class="n">optargs</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;, &#39;</span><span class="p">,</span> <span class="n">mod</span><span class="o">=</span><span class="s1">&#39;!r&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">weight_str</span><span class="p">:</span>
                <span class="n">inner_str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">inner_str</span><span class="p">,</span> <span class="n">weight_str</span><span class="p">])</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">inner_str</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inner_str</span> <span class="o">=</span> <span class="n">signature_string</span><span class="p">(</span><span class="n">posargs</span><span class="p">,</span> <span class="n">optargs</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">mod</span><span class="o">=</span><span class="s1">&#39;!r&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">weight_str</span><span class="p">:</span>
                <span class="n">inner_str</span> <span class="o">=</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">inner_str</span><span class="p">,</span> <span class="n">weight_str</span><span class="p">])</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                       <span class="n">indent_rows</span><span class="p">(</span><span class="n">inner_str</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">element_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;`ProductSpaceElement`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ProductSpaceElement</span></div>


<div class="viewcode-block" id="ProductSpaceElement"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceElement.html#odl.space.pspace.ProductSpaceElement">[docs]</a><span class="k">class</span> <span class="nc">ProductSpaceElement</span><span class="p">(</span><span class="n">LinearSpaceElement</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Elements of a `ProductSpace`.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">parts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">space</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__parts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parts of this product space element.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parts</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of factors of this element&#39;s space.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The data type of the space of this element.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">dtype</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``len(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">)</span>

<div class="viewcode-block" id="ProductSpaceElement.__eq__"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceElement.__eq__.html#odl.space.pspace.ProductSpaceElement.__eq__">[docs]</a>    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self == other``.</span>

<span class="sd">        Overrides the default `LinearSpace` method since it is</span>
<span class="sd">        implemented with the distance function, which is prone to</span>
<span class="sd">        numerical errors. This function checks equality per</span>
<span class="sd">        component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">other</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">sp</span> <span class="o">==</span> <span class="n">op</span> <span class="k">for</span> <span class="n">sp</span><span class="p">,</span> <span class="n">op</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">parts</span><span class="p">))</span></div>

<div class="viewcode-block" id="ProductSpaceElement.__getitem__"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceElement.__getitem__.html#odl.space.pspace.ProductSpaceElement.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self[indices]``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">out_parts</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">out_parts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;bad index type </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">indices</span><span class="p">)))</span></div>

<div class="viewcode-block" id="ProductSpaceElement.__setitem__"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceElement.__setitem__.html#odl.space.pspace.ProductSpaceElement.__setitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement ``self[indices] = values``.&quot;&quot;&quot;</span>
        <span class="c1"># Get the parts to which we assign values</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">indexed_parts</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="n">indices</span><span class="p">],)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">values</span><span class="p">,)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">indexed_parts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">indexed_parts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;bad index type </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">indices</span><span class="p">)))</span>

        <span class="c1"># Do the assignment, with broadcasting if desired</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># `values` is not iterable, assume it can be assigned to</span>
            <span class="c1"># all indexed parts</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">indexed_parts</span><span class="p">:</span>
                <span class="n">p</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># `values` is iterable; it could still represent a single</span>
            <span class="c1"># element of a power space.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">is_power_space</span> <span class="ow">and</span> <span class="n">values</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="c1"># Broadcast a single element across a power space</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">indexed_parts</span><span class="p">:</span>
                    <span class="n">p</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">values</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Now we really have one assigned value per part</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexed_parts</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;length of iterable `values` not equal to number of &#39;</span>
                        <span class="s1">&#39;indexed parts (</span><span class="si">{}</span><span class="s1"> != </span><span class="si">{}</span><span class="s1">)&#39;</span>
                        <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexed_parts</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indexed_parts</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
                    <span class="n">p</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">v</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ufuncs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;`ProductSpaceUfuncs`, access to Numpy style ufuncs.</span>

<span class="sd">        These are always available if the underlying spaces are</span>
<span class="sd">        `NtuplesBase`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; r22 = odl.ProductSpace(odl.rn(2), 2)</span>
<span class="sd">        &gt;&gt;&gt; x = r22.element([[1, -2], [-3, 4]])</span>
<span class="sd">        &gt;&gt;&gt; x.ufuncs.absolute()</span>
<span class="sd">        ProductSpace(rn(2), 2).element([</span>
<span class="sd">            [1.0, 2.0],</span>
<span class="sd">            [3.0, 4.0]</span>
<span class="sd">        ])</span>

<span class="sd">        These functions can also be used with non-vector arguments and</span>
<span class="sd">        support broadcasting, per component and even recursively:</span>

<span class="sd">        &gt;&gt;&gt; x.ufuncs.add([1, 2])</span>
<span class="sd">        ProductSpace(rn(2), 2).element([</span>
<span class="sd">            [2.0, 0.0],</span>
<span class="sd">            [-2.0, 6.0]</span>
<span class="sd">        ])</span>
<span class="sd">        &gt;&gt;&gt; x.ufuncs.subtract(1)</span>
<span class="sd">        ProductSpace(rn(2), 2).element([</span>
<span class="sd">            [0.0, -3.0],</span>
<span class="sd">            [-4.0, 3.0]</span>
<span class="sd">        ])</span>

<span class="sd">        There is also support for various reductions (sum, prod, min, max):</span>

<span class="sd">        &gt;&gt;&gt; x.ufuncs.sum()</span>
<span class="sd">        0.0</span>

<span class="sd">        Writing to ``out`` is also supported:</span>

<span class="sd">        &gt;&gt;&gt; y = r22.element()</span>
<span class="sd">        &gt;&gt;&gt; result = x.ufuncs.absolute(out=y)</span>
<span class="sd">        &gt;&gt;&gt; result</span>
<span class="sd">        ProductSpace(rn(2), 2).element([</span>
<span class="sd">            [1.0, 2.0],</span>
<span class="sd">            [3.0, 4.0]</span>
<span class="sd">        ])</span>
<span class="sd">        &gt;&gt;&gt; result is y</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        odl.util.ufuncs.NtuplesBaseUfuncs</span>
<span class="sd">            Base class for ufuncs in `NtuplesBase` spaces, subspaces may</span>
<span class="sd">            override this for greater efficiency.</span>
<span class="sd">        odl.util.ufuncs.ProductSpaceUfuncs</span>
<span class="sd">            For a list of available ufuncs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ProductSpaceUfuncs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``str(self)``.&quot;&quot;&quot;</span>
        <span class="n">inner_str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;{{</span><span class="si">{}</span><span class="s1">}}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inner_str</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from odl import rn  # need to import rn into namespace</span>
<span class="sd">        &gt;&gt;&gt; r2, r3 = odl.rn(2), odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; r2x3 = ProductSpace(r2, r3)</span>
<span class="sd">        &gt;&gt;&gt; x = r2x3.element([[1, 2], [3, 4, 5]])</span>
<span class="sd">        &gt;&gt;&gt; eval(repr(x)) == x</span>
<span class="sd">        True</span>

<span class="sd">        The result is readable:</span>

<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        ProductSpace(rn(2), rn(3)).element([</span>
<span class="sd">            [1.0, 2.0],</span>
<span class="sd">            [3.0, 4.0, 5.0]</span>
<span class="sd">        ])</span>

<span class="sd">        Nestled spaces work as well</span>

<span class="sd">        &gt;&gt;&gt; X = ProductSpace(r2x3, r2x3)</span>
<span class="sd">        &gt;&gt;&gt; x = X.element([[[1, 2], [3, 4, 5]],[[1, 2], [3, 4, 5]]])</span>
<span class="sd">        &gt;&gt;&gt; eval(repr(x)) == x</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        ProductSpace(ProductSpace(rn(2), rn(3)), 2).element([</span>
<span class="sd">            [</span>
<span class="sd">                [1.0, 2.0],</span>
<span class="sd">                [3.0, 4.0, 5.0]</span>
<span class="sd">            ],</span>
<span class="sd">            [</span>
<span class="sd">                [1.0, 2.0],</span>
<span class="sd">                [3.0, 4.0, 5.0]</span>
<span class="sd">            ]</span>
<span class="sd">        ])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inner_str</span> <span class="o">=</span> <span class="s1">&#39;[</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">inner_str</span> <span class="o">+=</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">_indent</span><span class="p">(</span><span class="n">_strip_space</span><span class="p">(</span><span class="n">part</span><span class="p">)))</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inner_str</span> <span class="o">+=</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">_indent</span><span class="p">(</span><span class="n">_strip_space</span><span class="p">(</span><span class="n">part</span><span class="p">)))</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">inner_str</span> <span class="o">+=</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">    ...</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">inner_str</span> <span class="o">+=</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">_indent</span><span class="p">(</span><span class="n">_strip_space</span><span class="p">(</span><span class="n">part</span><span class="p">)))</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:])</span>

        <span class="n">inner_str</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">]&#39;</span>

        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1">.element(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">,</span> <span class="n">inner_str</span><span class="p">)</span>

<div class="viewcode-block" id="ProductSpaceElement.show"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceElement.show.html#odl.space.pspace.ProductSpaceElement.show">[docs]</a>    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Display the parts of this product space element graphically.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        title : string, optional</span>
<span class="sd">            Title of the figures</span>

<span class="sd">        indices : index expression, optional</span>
<span class="sd">            Indices can refer to parts of a `ProductSpaceElement` and slices</span>
<span class="sd">            in the parts in the following way:</span>

<span class="sd">            Single index (``indices=0``)</span>
<span class="sd">            =&gt; display that part</span>

<span class="sd">            Single slice (``indices=slice(None)``), or</span>
<span class="sd">            index list (``indices=[0, 1, 3]``)</span>
<span class="sd">            =&gt; display those parts</span>

<span class="sd">            Any tuple, for example:</span>
<span class="sd">            Created by `numpy.s_` ``indices=np.s_[0, :, :]`` or</span>
<span class="sd">            Using a raw tuple ``indices=([0, 3], slice(None))``</span>
<span class="sd">            =&gt; take the first elements to select the parts and</span>
<span class="sd">            pass the rest on to the underlying show methods.</span>

<span class="sd">        kwargs</span>
<span class="sd">            Additional arguments passed on to the ``show`` methods of</span>
<span class="sd">            the parts.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : list of `matplotlib.figure.Figure`</span>
<span class="sd">            The resulting figures. It is also shown to the user.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        odl.discr.lp_discr.DiscreteLpElement.show :</span>
<span class="sd">            Display of a discretized function</span>
<span class="sd">        odl.space.base_ntuples.NtuplesBaseVector.show :</span>
<span class="sd">            Display of sequence type data</span>
<span class="sd">        odl.util.graphics.show_discrete_data :</span>
<span class="sd">            Underlying implementation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;ProductSpaceElement&#39;</span>

        <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">indices</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;indices&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">indices</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">indices</span><span class="p">]</span>

            <span class="c1"># else try with indices as is</span>

        <span class="n">in_figs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;fig&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">in_figs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="k">if</span> <span class="n">in_figs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">in_figs</span>

        <span class="n">figs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">part</span><span class="p">,</span> <span class="n">fig</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">in_figs</span><span class="p">):</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">. Part </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">figs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">fig</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">figs</span></div></div>


<span class="c1"># --- Add arithmetic operators that broadcast ---</span>
<span class="k">def</span> <span class="nf">_broadcast_arithmetic</span><span class="p">(</span><span class="n">op</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return ``op(self, other)`` with broadcasting.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    op : string</span>
<span class="sd">        Name of the operator, e.g. ``&#39;__add__&#39;``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    broadcast_arithmetic_op : function</span>
<span class="sd">        Function intended to be used as a method for `ProductSpaceVector`</span>
<span class="sd">        which performs broadcasting if possible.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Broadcasting is the operation of &quot;applying an operator multiple times&quot; in</span>
<span class="sd">    some sense. For example:</span>

<span class="sd">    .. math::</span>
<span class="sd">        (1, 2) + 1 = (2, 3)</span>

<span class="sd">    is a form of broadcasting. In this implementation, we only allow &quot;single</span>
<span class="sd">    layer&quot; broadcasting, i.e., we do not support broadcasting over several</span>
<span class="sd">    product spaces at once.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_broadcast_arithmetic_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">is_power_space</span> <span class="ow">and</span> <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">op</span><span class="p">)(</span><span class="n">other</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">NotImplemented</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">LinearSpaceElement</span><span class="p">,</span> <span class="n">op</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="c1"># Set docstring</span>
    <span class="n">docstring</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Broadcasted </span><span class="si">{op}</span><span class="s2">.&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">op</span><span class="p">)</span>
    <span class="n">_broadcast_arithmetic_impl</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">docstring</span>

    <span class="k">return</span> <span class="n">_broadcast_arithmetic_impl</span>


<span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;add&#39;</span><span class="p">,</span> <span class="s1">&#39;sub&#39;</span><span class="p">,</span> <span class="s1">&#39;mul&#39;</span><span class="p">,</span> <span class="s1">&#39;div&#39;</span><span class="p">,</span> <span class="s1">&#39;truediv&#39;</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">modifier</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">]:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;__</span><span class="si">{}{}</span><span class="s1">__&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">modifier</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">ProductSpaceElement</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">_broadcast_arithmetic</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>


<div class="viewcode-block" id="ProductSpaceArrayWeighting"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceArrayWeighting.html#odl.space.pspace.ProductSpaceArrayWeighting">[docs]</a><span class="k">class</span> <span class="nc">ProductSpaceArrayWeighting</span><span class="p">(</span><span class="n">ArrayWeighting</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Array weighting for `ProductSpace`.</span>

<span class="sd">    This class defines a weighting that has a different value for</span>
<span class="sd">    each index defined in a given space.</span>
<span class="sd">    See ``Notes`` for mathematical details.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">dist_using_inner</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        array : 1-dim. `array-like`</span>
<span class="sd">            Weighting array of the inner product.</span>
<span class="sd">        exponent : positive float, optional</span>
<span class="sd">            Exponent of the norm. For values other than 2.0, no inner</span>
<span class="sd">            product is defined.</span>
<span class="sd">        dist_using_inner : bool, optional</span>
<span class="sd">            Calculate ``dist`` using the formula</span>

<span class="sd">                ``||x - y||^2 = ||x||^2 + ||y||^2 - 2 * Re &lt;x, y&gt;``.</span>

<span class="sd">            This avoids the creation of new arrays and is thus faster</span>
<span class="sd">            for large arrays. On the downside, it will not evaluate to</span>
<span class="sd">            exactly zero for equal (but not identical) ``x`` and ``y``.</span>

<span class="sd">            Can only be used if ``exponent`` is 2.0.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - For exponent 2.0, a new weighted inner product with array</span>
<span class="sd">          :math:`w` is defined as</span>

<span class="sd">          .. math::</span>
<span class="sd">              \\langle x, y \\rangle_w = \\langle w \odot x, y \\rangle</span>

<span class="sd">          with component-wise multiplication :math:`w \odot x`. For other</span>
<span class="sd">          exponents, only ``norm`` and ``dist`` are defined. In the case</span>
<span class="sd">          of exponent ``inf``, the weighted norm is</span>

<span class="sd">          .. math::</span>
<span class="sd">              \|x\|_{w,\infty} = \|w \odot x\|_\infty,</span>

<span class="sd">          otherwise it is</span>

<span class="sd">          .. math::</span>
<span class="sd">              \|x\|_{w,p} = \|w^{1/p} \odot x\|_p.</span>

<span class="sd">        - Note that this definition does **not** fulfill the limit property</span>
<span class="sd">          in :math:`p`, i.e.,</span>

<span class="sd">          .. math::</span>
<span class="sd">              \|x\|_{w,p} \\not\\to \|x\|_{w,\infty}</span>
<span class="sd">              \quad\\text{for } p \\to \infty</span>

<span class="sd">          unless :math:`w = (1,...,1)`. The reason for this choice</span>
<span class="sd">          is that the alternative with the limit property consists in</span>
<span class="sd">          ignoring the weights altogether.</span>

<span class="sd">        - The array may only have positive entries, otherwise it does not</span>
<span class="sd">          define an inner product or norm, respectively. This is not checked</span>
<span class="sd">          during initialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="n">exponent</span><span class="p">,</span>
                         <span class="n">dist_using_inner</span><span class="o">=</span><span class="n">dist_using_inner</span><span class="p">)</span>

<div class="viewcode-block" id="ProductSpaceArrayWeighting.inner"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceArrayWeighting.inner.html#odl.space.pspace.ProductSpaceArrayWeighting.inner">[docs]</a>    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the array-weighted inner product of two elements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x1, x2 : `ProductSpaceElement`</span>
<span class="sd">            Elements whose inner product is calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inner : float or complex</span>
<span class="sd">            The inner product of the two provided elements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">!=</span> <span class="mf">2.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;no inner product defined for &#39;</span>
                                      <span class="s1">&#39;exponent != 2 (got </span><span class="si">{}</span><span class="s1">)&#39;</span>
                                      <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">))</span>

        <span class="n">inners</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span>
            <span class="p">(</span><span class="n">x1i</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">x2i</span><span class="p">)</span> <span class="k">for</span> <span class="n">x1i</span><span class="p">,</span> <span class="n">x2i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">))</span>

        <span class="n">inner</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inners</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_real_dtype</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">complex</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span></div>

<div class="viewcode-block" id="ProductSpaceArrayWeighting.norm"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceArrayWeighting.norm.html#odl.space.pspace.ProductSpaceArrayWeighting.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the array-weighted norm of an element.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : `ProductSpaceElement`</span>
<span class="sd">            Element whose norm is calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        norm : float</span>
<span class="sd">            The norm of the provided element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mf">2.0</span><span class="p">:</span>
            <span class="n">norm_squared</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>  <span class="c1"># TODO: optimize?!</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">norm_squared</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">norms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span>
                <span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="ow">in</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)):</span>
                <span class="n">norms</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">norms</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span>

            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">norms</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="ProductSpaceConstWeighting"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceConstWeighting.html#odl.space.pspace.ProductSpaceConstWeighting">[docs]</a><span class="k">class</span> <span class="nc">ProductSpaceConstWeighting</span><span class="p">(</span><span class="n">ConstWeighting</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Constant weighting for `ProductSpace`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constant</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">dist_using_inner</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        constant : positive float</span>
<span class="sd">            Weighting constant of the inner product</span>
<span class="sd">        exponent : positive float, optional</span>
<span class="sd">            Exponent of the norm. For values other than 2.0, no inner</span>
<span class="sd">            product is defined.</span>
<span class="sd">        dist_using_inner : bool, optional</span>
<span class="sd">            Calculate ``dist`` using the formula</span>

<span class="sd">                ``||x - y||^2 = ||x||^2 + ||y||^2 - 2 * Re &lt;x, y&gt;``</span>

<span class="sd">            This avoids the creation of new arrays and is thus faster</span>
<span class="sd">            for large arrays. On the downside, it will not evaluate to</span>
<span class="sd">            exactly zero for equal (but not identical) ``x`` and ``y``.</span>

<span class="sd">            Can only be used if ``exponent`` is 2.0.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - For exponent 2.0, a new weighted inner product with constant</span>
<span class="sd">          :math:`c` is defined as</span>

<span class="sd">          .. math::</span>
<span class="sd">            \\langle x, y \\rangle_c = c\, \\langle x, y \\rangle.</span>

<span class="sd">          For other exponents, only ``norm`` and ```dist`` are defined.</span>
<span class="sd">          In the case of exponent ``inf``, the weighted norm is</span>

<span class="sd">          .. math::</span>
<span class="sd">              \|x\|_{c,\infty} = c\, \|x\|_\infty,</span>

<span class="sd">          otherwise it is</span>

<span class="sd">          .. math::</span>
<span class="sd">              \|x\|_{c,p} = c^{1/p} \, \|x\|_p.</span>

<span class="sd">        - Note that this definition does **not** fulfill the limit property</span>
<span class="sd">          in :math:`p`, i.e.,</span>

<span class="sd">          .. math::</span>
<span class="sd">              \|x\|_{c,p} \\not\\to \|x\|_{c,\infty}</span>
<span class="sd">              \quad \\text{for } p \\to \infty</span>

<span class="sd">          unless :math:`c = 1`. The reason for this choice</span>
<span class="sd">          is that the alternative with the limit property consists in</span>
<span class="sd">          ignoring the weight altogether.</span>

<span class="sd">        - The constant must be positive, otherwise it does not define an</span>
<span class="sd">          inner product or norm, respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">constant</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="n">exponent</span><span class="p">,</span>
                         <span class="n">dist_using_inner</span><span class="o">=</span><span class="n">dist_using_inner</span><span class="p">)</span>

<div class="viewcode-block" id="ProductSpaceConstWeighting.inner"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceConstWeighting.inner.html#odl.space.pspace.ProductSpaceConstWeighting.inner">[docs]</a>    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the constant-weighted inner product of two elements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x1, x2 : `ProductSpaceElement`</span>
<span class="sd">            Elements whose inner product is calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inner : float or complex</span>
<span class="sd">            The inner product of the two provided elements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">!=</span> <span class="mf">2.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;no inner product defined for &#39;</span>
                                      <span class="s1">&#39;exponent != 2 (got </span><span class="si">{}</span><span class="s1">)&#39;</span>
                                      <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">))</span>

        <span class="n">inners</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span>
            <span class="p">(</span><span class="n">x1i</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">x2i</span><span class="p">)</span> <span class="k">for</span> <span class="n">x1i</span><span class="p">,</span> <span class="n">x2i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">))</span>

        <span class="n">inner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">inners</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x1</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">field</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span></div>

<div class="viewcode-block" id="ProductSpaceConstWeighting.norm"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceConstWeighting.norm.html#odl.space.pspace.ProductSpaceConstWeighting.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the constant-weighted norm of an element.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x1 : `ProductSpaceElement`</span>
<span class="sd">            Element whose norm is calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        norm : float</span>
<span class="sd">            The norm of the element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mf">2.0</span><span class="p">:</span>
            <span class="n">norm_squared</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>  <span class="c1"># TODO: optimize?!</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">norm_squared</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">norms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span>
                <span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="ow">in</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)):</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="o">*</span>
                        <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">norms</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span> <span class="o">*</span>
                        <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">norms</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)))</span></div>

<div class="viewcode-block" id="ProductSpaceConstWeighting.dist"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceConstWeighting.dist.html#odl.space.pspace.ProductSpaceConstWeighting.dist">[docs]</a>    <span class="k">def</span> <span class="nf">dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the constant-weighted distance between two elements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x1, x2 : `ProductSpaceElement`</span>
<span class="sd">            Elements whose mutual distance is calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dist : float</span>
<span class="sd">            The distance between the elements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_using_inner</span><span class="p">:</span>
            <span class="n">norms1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span>
                <span class="p">(</span><span class="n">x1i</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="k">for</span> <span class="n">x1i</span> <span class="ow">in</span> <span class="n">x1</span><span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">))</span>
            <span class="n">norm1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">norms1</span><span class="p">)</span>

            <span class="n">norms2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span>
                <span class="p">(</span><span class="n">x2i</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="k">for</span> <span class="n">x2i</span> <span class="ow">in</span> <span class="n">x2</span><span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">x2</span><span class="p">))</span>
            <span class="n">norm2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">norms2</span><span class="p">)</span>

            <span class="n">inners</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span>
                <span class="p">(</span><span class="n">x1i</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">x2i</span><span class="p">)</span> <span class="k">for</span> <span class="n">x1i</span><span class="p">,</span> <span class="n">x2i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">))</span>
            <span class="n">inner_re</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">inners</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>

            <span class="n">dist_squared</span> <span class="o">=</span> <span class="n">norm1</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">norm2</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">inner_re</span>
            <span class="k">if</span> <span class="n">dist_squared</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>  <span class="c1"># Compensate for numerical error</span>
                <span class="n">dist_squared</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">)</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dist_squared</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dnorms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span>
                <span class="p">((</span><span class="n">x1i</span> <span class="o">-</span> <span class="n">x2i</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="k">for</span> <span class="n">x1i</span><span class="p">,</span> <span class="n">x2i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">))</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dnorms</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span> <span class="o">*</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dnorms</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="ProductSpaceNoWeighting"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceNoWeighting.html#odl.space.pspace.ProductSpaceNoWeighting">[docs]</a><span class="k">class</span> <span class="nc">ProductSpaceNoWeighting</span><span class="p">(</span><span class="n">NoWeighting</span><span class="p">,</span> <span class="n">ProductSpaceConstWeighting</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Weighting of `ProductSpace` with constant 1.&quot;&quot;&quot;</span>

    <span class="c1"># Implement singleton pattern for efficiency in the default case</span>
    <span class="n">_instance</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement singleton pattern if ``exp==2.0``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">exponent</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;exponent&#39;</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
            <span class="n">dist_using_inner</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dist_using_inner&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">exponent</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">dist_using_inner</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dist_using_inner&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">exponent</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dist_using_inner</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>

        <span class="k">if</span> <span class="n">exponent</span> <span class="o">==</span> <span class="mf">2.0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dist_using_inner</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_instance</span><span class="p">:</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_instance</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_instance</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">dist_using_inner</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        exponent : positive float, optional</span>
<span class="sd">            Exponent of the norm. For values other than 2.0, the inner</span>
<span class="sd">            product is not defined.</span>
<span class="sd">        dist_using_inner : bool, optional</span>
<span class="sd">            Calculate ``dist`` using the formula</span>

<span class="sd">                ``||x - y||^2 = ||x||^2 + ||y||^2 - 2 * Re &lt;x, y&gt;``</span>

<span class="sd">            This avoids the creation of new arrays and is thus faster</span>
<span class="sd">            for large arrays. On the downside, it will not evaluate to</span>
<span class="sd">            exactly zero for equal (but not identical) ``x`` and ``y``.</span>

<span class="sd">            Can only be used if ``exponent`` is 2.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">impl</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="n">exponent</span><span class="p">,</span>
                         <span class="n">dist_using_inner</span><span class="o">=</span><span class="n">dist_using_inner</span><span class="p">)</span></div>


<div class="viewcode-block" id="ProductSpaceCustomInner"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceCustomInner.html#odl.space.pspace.ProductSpaceCustomInner">[docs]</a><span class="k">class</span> <span class="nc">ProductSpaceCustomInner</span><span class="p">(</span><span class="n">CustomInner</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Class for handling a user-specified inner products.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inner</span><span class="p">,</span> <span class="n">dist_using_inner</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inner : callable</span>
<span class="sd">            The inner product implementation. It must accept two</span>
<span class="sd">            `ProductSpaceElement` arguments, return a element from</span>
<span class="sd">            the field of the space (real or complex number) and</span>
<span class="sd">            satisfy the following conditions for all space elements</span>
<span class="sd">            ``x, y, z`` and scalars ``s``:</span>

<span class="sd">            - ``&lt;x, y&gt; = conj(&lt;y, x&gt;)``</span>
<span class="sd">            - ``&lt;s*x + y, z&gt; = s * &lt;x, z&gt; + &lt;y, z&gt;``</span>
<span class="sd">            - ``&lt;x, x&gt; = 0``  if and only if  ``x = 0``</span>

<span class="sd">        dist_using_inner : bool, optional</span>
<span class="sd">            Calculate ``dist`` using the formula</span>

<span class="sd">                ``||x - y||^2 = ||x||^2 + ||y||^2 - 2 * Re &lt;x, y&gt;``</span>

<span class="sd">            This avoids the creation of new arrays and is thus faster</span>
<span class="sd">            for large arrays. On the downside, it will not evaluate to</span>
<span class="sd">            exactly zero for equal (but not identical) ``x`` and ``y``.</span>

<span class="sd">            Can only be used if ``exponent`` is 2.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">impl</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="n">inner</span><span class="o">=</span><span class="n">inner</span><span class="p">,</span>
                         <span class="n">dist_using_inner</span><span class="o">=</span><span class="n">dist_using_inner</span><span class="p">)</span></div>


<div class="viewcode-block" id="ProductSpaceCustomNorm"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceCustomNorm.html#odl.space.pspace.ProductSpaceCustomNorm">[docs]</a><span class="k">class</span> <span class="nc">ProductSpaceCustomNorm</span><span class="p">(</span><span class="n">CustomNorm</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Class for handling a user-specified norm on `ProductSpace`.</span>

<span class="sd">    Note that this removes ``inner``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">norm</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        norm : callable</span>
<span class="sd">            The norm implementation. It must accept a</span>
<span class="sd">            `ProductSpaceElement` argument, return a float and satisfy</span>
<span class="sd">            the following conditions for all space elements</span>
<span class="sd">            ``x, y`` and scalars ``s``:</span>

<span class="sd">            - ``||x|| &gt;= 0``</span>
<span class="sd">            - ``||x|| = 0``  if and only if  ``x = 0``</span>
<span class="sd">            - ``||s * x|| = |s| * ||x||``</span>
<span class="sd">            - ``||x + y|| &lt;= ||x|| + ||y||``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="ProductSpaceCustomDist"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceCustomDist.html#odl.space.pspace.ProductSpaceCustomDist">[docs]</a><span class="k">class</span> <span class="nc">ProductSpaceCustomDist</span><span class="p">(</span><span class="n">CustomDist</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Class for handling a user-specified distance on `ProductSpace`.</span>

<span class="sd">    Note that this removes ``inner`` and ``norm``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dist : callable</span>
<span class="sd">            The distance function defining a metric on</span>
<span class="sd">            `ProductSpace`. It must accept two `ProductSpaceElement`</span>
<span class="sd">            arguments and fulfill the following mathematical conditions</span>
<span class="sd">            for any three space elements ``x, y, z``:</span>

<span class="sd">            - ``dist(x, y) &gt;= 0``</span>
<span class="sd">            - ``dist(x, y) = 0``  if and only if  ``x = y``</span>
<span class="sd">            - ``dist(x, y) = dist(y, x)``</span>
<span class="sd">            - ``dist(x, y) &lt;= dist(x, z) + dist(z, y)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_strip_space</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Strip the SPACE.element( ... ) part from a repr.&quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">space_repr</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1">.element(&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">space</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">space_repr</span><span class="p">)</span> <span class="ow">and</span> <span class="n">r</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">space_repr</span><span class="p">):</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">r</span>


<span class="k">def</span> <span class="nf">_indent</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Indent a string by 4 characters.&quot;&quot;&quot;</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
        <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;    &#39;</span> <span class="o">+</span> <span class="n">line</span>
    <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># pylint: disable=wrong-import-position</span>
    <span class="kn">from</span> <span class="nn">odl.util.testutils</span> <span class="k">import</span> <span class="n">run_doctests</span>
    <span class="n">run_doctests</span><span class="p">()</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-2017, ODL development group.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.6.1.dev0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>